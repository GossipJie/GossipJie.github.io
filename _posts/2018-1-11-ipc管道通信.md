---
layout: post
title:  "ipc之管道概述"
categories: share
---
---------------------------------------------------------

### 1、概述

1. 管道是一种用于在进程间共享数据的机制，其实质是一段共享内存。Windows系统为这段共享的内存设计采用数据流I/0的方式来访问。由一个进程读、另一个进程写，类似于一个管道两端，因此这种进程间的通信方式称作“管道”。
1. 匿名管道只能在父子进程间进行通信，不能在网络间通信，而且数据传输是单向的，只能一端写，另一端读。
1. 命令管道可以在任意进程间通信，通信是双向的，任意一端都可读可写，但是在同一时间只能有一端读、一端写。

### 2、管道提供了简单的流控制机制

- 在传统的实现中，管道是单向的，先入先出的，无结构的，固定大小的数据流。写进程是在管道的尾端写入，读进程是在管道的首端读出数据。
- 数据读出后，将从管道移走，其他读进程不能再读取这些数据。
- 系统调用pipe生成一个管道并返回两个描述符，一个用来读取管道，一个用来写管道。
- 通常管道被两个进程共享，每个进程拥有管道的一端。对管道的IO操作和对文件的IO操作非常类似。通过对管道描述符调用read和write系统调用来操作。进程通常不知道它正在读或者写的实际上是管道。

### 3、常用API

Pipes[2]

### 4、管道通信过程

1. 服务器端

创建管道 => 监听 => 读写 => 关闭

CreateNamedPipe<br>
ConnectNamedPipe<br>
ReadFile/WriteFile<br>
DisconnectNamedPipe<br>

实例代码：

``` C++
/*
通过pipe进程间通信
**************************************/
/* 头文件 */
#include <windows.h> 
#include <stdio.h>
#include <tchar.h>
/* 常量 */
#define PIPE_TIMEOUT 5000
#define BUFSIZE 4096
/* 结构定义 */
typedef struct 
{ 
    OVERLAPPED oOverlap; 
    HANDLE hPipeInst; 
    TCHAR chRequest[BUFSIZE]; 
    DWORD cbRead;
    TCHAR chReply[BUFSIZE]; 
    DWORD cbToWrite; 
} PIPEINST, *LPPIPEINST; 
/* 函数声明 */
VOID DisconnectAndClose(LPPIPEINST); 
BOOL CreateAndConnectInstance(LPOVERLAPPED); 
BOOL ConnectToNewClient(HANDLE, LPOVERLAPPED); 
VOID GetAnswerToRequest(LPPIPEINST); 
VOID WINAPI CompletedWriteRoutine(DWORD, DWORD, LPOVERLAPPED); 
VOID WINAPI CompletedReadRoutine(DWORD, DWORD, LPOVERLAPPED); 
/* 全局变量 */
HANDLE hPipe; 
/* ************************************
* int main(VOID) 
* 功能    pipe 通信服务端主函数
**************************************/
int main(VOID) 
{ 
    HANDLE hConnectEvent; 
    OVERLAPPED oConnect; 
    LPPIPEINST lpPipeInst; 
    DWORD dwWait, cbRet; 
    BOOL fSuccess, fPendingIO; 

    // 用于连接操作的事件对象 
    hConnectEvent = CreateEvent( 
        NULL,    // 默认属性
        TRUE,    // 手工reset
        TRUE,    // 初始状态 signaled 
        NULL);   // 未命名

    if (hConnectEvent == NULL) 
    {
        printf("CreateEvent failed with %d.\n", GetLastError()); 
        return 0;
    }
    // OVERLAPPED 事件
    oConnect.hEvent = hConnectEvent; 

    // 创建连接实例，等待连接
    fPendingIO = CreateAndConnectInstance(&oConnect); 

    while (1) 
    {
        // 等待客户端连接或读写操作完成 
        dwWait = WaitForSingleObjectEx( 
            hConnectEvent,  // 等待的事件 
            INFINITE,       // 无限等待
            TRUE);       

        switch (dwWait) 
        { 
        case 0:        
            // pending 
            if (fPendingIO) 
            { 
                // 获取 Overlapped I/O 的结果
                fSuccess = GetOverlappedResult( 
                    hPipe,     // pipe 句柄 
                    &oConnect, // OVERLAPPED 结构 
                    &cbRet,    // 已经传送的数据量
                    FALSE);    // 不等待
                if (!fSuccess) 
                {
                    printf("ConnectNamedPipe (%d)\n", GetLastError()); 
                    return 0;
                }
            } 

            // 分配内存 
            lpPipeInst = (LPPIPEINST) HeapAlloc(GetProcessHeap(),0,sizeof(PIPEINST)); 
            if (lpPipeInst == NULL) 
            {
                printf("GlobalAlloc failed (%d)\n", GetLastError()); 
                return 0;
            }
            lpPipeInst->hPipeInst = hPipe; 

            // 读和写，注意CompletedWriteRoutine和CompletedReadRoutine的相互调用
            lpPipeInst->cbToWrite = 0; 
            CompletedWriteRoutine(0, 0, (LPOVERLAPPED) lpPipeInst); 

            // 再创建一个连接实例，以响应下一个客户端的连接
            fPendingIO = CreateAndConnectInstance( 
                &oConnect); 
            break; 

            // 读写完成 
        case WAIT_IO_COMPLETION: 
            break; 

        default: 
            {
                printf("WaitForSingleObjectEx (%d)\n", GetLastError()); 
                return 0;
            }
        } 
    } 
    return 0; 
} 

/* ************************************
* CompletedWriteRoutine 
*     写入pipe操作的完成函数
*    接口参见FileIOCompletionRoutine回调函数定义
*
*    当写操作完成时被调用，开始读另外一个客户端的请求
**************************************/
VOID WINAPI CompletedWriteRoutine(
                                  DWORD dwErr, 
                                  DWORD cbWritten, 
                                  LPOVERLAPPED lpOverLap) 
{ 
    LPPIPEINST lpPipeInst; 
    BOOL fRead = FALSE; 
    // 保存overlap实例
    lpPipeInst = (LPPIPEINST) lpOverLap; 

// 如果没有错误
    if ((dwErr == 0) && (cbWritten == lpPipeInst->cbToWrite)) 
    {        
        fRead = ReadFileEx( 
        lpPipeInst->hPipeInst, 
        lpPipeInst->chRequest, 
        BUFSIZE*sizeof(TCHAR), 
        (LPOVERLAPPED) lpPipeInst, 
        // 写读操作完成后，调用CompletedReadRoutine
        (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine); 
    }    
    if (! fRead) 
        // 出错，断开连接
        DisconnectAndClose(lpPipeInst); 
} 

/* ************************************
* CompletedReadRoutine 
*     读取pipe操作的完成函数
*    接口参见FileIOCompletionRoutine回调函数定义
*
*    当读操作完成时被调用，写入回复
**************************************/
VOID WINAPI CompletedReadRoutine(
                                 DWORD dwErr, 
                                 DWORD cbBytesRead, 
                                 LPOVERLAPPED lpOverLap) 
{ 
    LPPIPEINST lpPipeInst; 
    BOOL fWrite = FALSE; 

    // 保存overlap实例
    lpPipeInst = (LPPIPEINST) lpOverLap; 

    // 如果没有错误
    if ((dwErr == 0) && (cbBytesRead != 0)) 
    { 
        // 根据客户端的请求，生成回复
        GetAnswerToRequest(lpPipeInst); 
        // 将回复写入到pipe
        fWrite = WriteFileEx( 
            lpPipeInst->hPipeInst, 
            lpPipeInst->chReply,    //将响应写入pipe
            lpPipeInst->cbToWrite, 
            (LPOVERLAPPED) lpPipeInst, 
            // 写入完成后，调用CompletedWriteRoutine
            (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedWriteRoutine); 
    } 

    if (! fWrite) 
        // 出错，断开连接
        DisconnectAndClose(lpPipeInst); 
} 

/* ************************************
* VOID DisconnectAndClose(LPPIPEINST lpPipeInst) 
* 功能    断开一个连接的实例
* 参数    lpPipeInst，断开并关闭的实例句柄
**************************************/
VOID DisconnectAndClose(LPPIPEINST lpPipeInst) 
{ 
    // 关闭连接实例
    if (! DisconnectNamedPipe(lpPipeInst->hPipeInst) ) 
    {
        printf("DisconnectNamedPipe failed with %d.\n", GetLastError());
    }
    // 关闭 pipe 实例的句柄 
    CloseHandle(lpPipeInst->hPipeInst); 
    // 释放
    if (lpPipeInst != NULL) 
        HeapFree(GetProcessHeap(),0, lpPipeInst); 
} 

/* ************************************
* BOOL CreateAndConnectInstance(LPOVERLAPPED lpoOverlap)
* 功能    建立连接实例
* 参数    lpoOverlap，用于overlapped IO的结构
* 返回值    是否成功
**************************************/
BOOL CreateAndConnectInstance(LPOVERLAPPED lpoOverlap) 
{ 
    LPTSTR lpszPipename = TEXT("\\\\.\\pipe\\samplenamedpipe"); 
    // 创建named pipe     
    hPipe = CreateNamedPipe( 
        lpszPipename,             // pipe 名 
        PIPE_ACCESS_DUPLEX |      // 可读可写
        FILE_FLAG_OVERLAPPED,     // overlapped 模式 
        // pipe模式
        PIPE_TYPE_MESSAGE |       // 消息类型 pipe 
        PIPE_READMODE_MESSAGE |   // 消息读模式 
        PIPE_WAIT,                // 阻塞模式
        PIPE_UNLIMITED_INSTANCES, // 无限制实例
        BUFSIZE*sizeof(TCHAR),    // 输出缓存大小
        BUFSIZE*sizeof(TCHAR),    // 输入缓存大小
        PIPE_TIMEOUT,             // 客户端超时
        NULL);                    // 默认安全属性
    if (hPipe == INVALID_HANDLE_VALUE) 
    {
        printf("CreateNamedPipe failed with %d.\n", GetLastError()); 
        return 0;
    }

    // 连接到新的客户端
    return ConnectToNewClient(hPipe, lpoOverlap); 
}

/* ************************************
* BOOL ConnectToNewClient(HANDLE hPipe, LPOVERLAPPED lpo)
* 功能    建立连接实例
* 参数    lpoOverlap，用于overlapped IO的结构
* 返回值    是否成功
**************************************/
BOOL ConnectToNewClient(HANDLE hPipe, LPOVERLAPPED lpo) 
{ 
    BOOL fConnected, fPendingIO = FALSE; 

    // 开始一个 overlapped 连接 
    fConnected = ConnectNamedPipe(hPipe, lpo); 

    if (fConnected) 
    {
        printf("ConnectNamedPipe failed with %d.\n", GetLastError()); 
        return 0;
    }
    switch (GetLastError()) 
    { 
        // overlapped连接进行中. 
    case ERROR_IO_PENDING: 
        fPendingIO = TRUE; 
        break; 
        // 已经连接，因此Event未置位 
    case ERROR_PIPE_CONNECTED: 
        if (SetEvent(lpo->hEvent)) 
            break; 
        // error
    default: 
        {
            printf("ConnectNamedPipe failed with %d.\n", GetLastError());
            return 0;
        }
    } 
    return fPendingIO; 
}

// TODO根据客户端的请求，给出响应
VOID GetAnswerToRequest(LPPIPEINST pipe)
{
    _tprintf( TEXT("[%d] %s\n"), pipe->hPipeInst, pipe->chRequest);
    lstrcpyn( pipe->chReply,  TEXT("Default answer from server") ,BUFSIZE);
    pipe->cbToWrite = (lstrlen(pipe->chReply)+1)*sizeof(TCHAR);
}
```

1. 客户端

打开命令管道，获得句柄 => 写入数据 => 等待回复

WaitNamedPipe <br>
SetNamedPipeHandleState

``` typescript
/**
*IPC管道通信服务
*/
class IpcService extends EventEmitter {
  //ipc进程
  ipcWorker: child_process.ChildProcess
  //服务端管道名
  serverPipe: string

  /**
   * 发送管道消息
   * @param pipeName
   * @param data
   */
  send(pipeName: string, data: any) {
    this.ipcWorker.send({
      type: 'send',
      data: {
        pipe: pipeName,
        data: data
      }
    })
  }
  /**
   * 关闭管道
   */
  quit() {
    this.ipcWorker.send({
      type: 'close'
    })
    this.ipcWorker.kill()
  }

  /**
  * 构造ipc管道通信服务
  */
  constructor() {
    //初始化ipc进程
    this.ipcWorker = child_process.fork(path.join(guiService.getAppPath(), 'workers/ipc.js'), [this.serverPipe])
    //监听管道信息
    this.ipcWorker.on('message',(message: InputMessage) => {
      if (message.type === 'ready') {
        this.emit('ready')
      }
      if (message.type === 'message') {
        if (message.data.action) {
          this.emit(message.data.action, message.data)
        }
        if (message.data.from) {
          this.emit(message.data.from, message.data)
        }
      }
      if (message.type === 'error') {
        logger.trace('ipc error', message.data)
      }
    })
  }
}

```
